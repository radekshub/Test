<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebGL Waterfall - rotated signed signal</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: black;}
    canvas { width: 512px; height: 512px; display: block; margin: auto; background: black; }
  </style>
</head>
<body>
<canvas id="glcanvas" width="512" height="512"></canvas>
<script>
const gl = document.getElementById("glcanvas").getContext("webgl");
if (!gl) alert("WebGL není podporován");

const vsSource = `
attribute vec2 position;
varying vec2 vUv;
void main() {
  vUv = (position + 1.0) * 0.5;
  gl_Position = vec4(position, 0, 1);
}
`;

const fsSource = `
precision mediump float;
varying vec2 vUv;
uniform sampler2D uPrevTex;
uniform sampler2D uInputTex;

float signedValueFromTex(vec4 color) {
  return color.r * 255.0 - 128.0;
}

vec3 colorMap(float val) {
  float norm = (val + 128.0) / 255.0;
  if (norm < 0.5) {
    return mix(vec3(0.0, 0.0, 1.0), vec3(0.0,1.0,0.0), norm * 2.0);
  } else {
    return mix(vec3(0.0,1.0,0.0), vec3(1.0,0.0,0.0), (norm - 0.5) * 2.0);
  }
}

void main() {
  float lineHeight = 1.0 / 512.0;

  if (vUv.y < 1.0 - lineHeight) {
    // zkopíruj celý pixel z předchozí textury – žádné přepočítávání
    gl_FragColor = texture2D(uPrevTex, vec2(vUv.x, vUv.y + lineHeight));
  } else {
    // nový řádek (horní): spočítej barvu z hodnoty
    vec4 inputColor = texture2D(uInputTex, vec2(vUv.x, 0.0));
    float val = signedValueFromTex(inputColor);
    vec3 col = colorMap(val);
    gl_FragColor = vec4(col, 1.0);
  }
}
`;

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error("Shader compile failed:", gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function createProgram(gl, vsSource, fsSource) {
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Program link failed:", gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    return null;
  }
  return program;
}

const program = createProgram(gl, vsSource, fsSource);
gl.useProgram(program);

const posBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
const positions = new Float32Array([
  -1, -1,  1, -1,  -1, 1,
  -1,  1,  1, -1,   1, 1
]);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const positionLoc = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

function createTexture(width, height) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(
    gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0,
    gl.RGBA, gl.UNSIGNED_BYTE, null
  );
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return tex;
}

const texWidth = 512;
const texHeight = 512;

const texA = createTexture(texWidth, texHeight);
const texB = createTexture(texWidth, texHeight);
const framebuffer = gl.createFramebuffer();
const inputTex = createTexture(texWidth, 1);

const uPrevTexLoc = gl.getUniformLocation(program, "uPrevTex");
const uInputTexLoc = gl.getUniformLocation(program, "uInputTex");

let t = 0;

// Vytvoříme základní vektor -128 až 127
const baseSignal = new Int8Array(texWidth);
for(let i = 0; i < texWidth; i++) baseSignal[i] = i - 128;

function generateRotatedSignalLine() {
  const data = new Uint8Array(texWidth * 4);
  const offset = t % texWidth;
  for (let i = 0; i < texWidth; i++) {
    // rotace indexu s wrapem
    const idx = (i + offset) % texWidth;
    const val = baseSignal[idx];
    const shifted = val + 128;  // převedeme na 0..255
    data[i * 4 + 0] = shifted;  // R
    data[i * 4 + 1] = 0;        // G
    data[i * 4 + 2] = 0;        // B
    data[i * 4 + 3] = 255;      // A
  }
  t++;
  gl.bindTexture(gl.TEXTURE_2D, inputTex);
  gl.texSubImage2D(
    gl.TEXTURE_2D, 0, 0, 0, texWidth, 1,
    gl.RGBA, gl.UNSIGNED_BYTE, data
  );
}

function checkFramebuffer() {
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  if (status !== gl.FRAMEBUFFER_COMPLETE) {
    console.error("Framebuffer incomplete: ", status);
    return false;
  }
  return true;
}

let frontTex = texA;
let backTex = texB;

function render() {
  generateRotatedSignalLine();

  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, backTex, 0);

  if (!checkFramebuffer()) {
    alert("Framebuffer incomplete!");
    return;
  }

  gl.viewport(0, 0, texWidth, texHeight);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, frontTex);
  gl.uniform1i(uPrevTexLoc, 0);

  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, inputTex);
  gl.uniform1i(uInputTexLoc, 1);

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  [frontTex, backTex] = [backTex, frontTex];

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, frontTex);
  gl.uniform1i(uPrevTexLoc, 0);

  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, inputTex);
  gl.uniform1i(uInputTexLoc, 1);

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  requestAnimationFrame(render);
}

render();

</script>
</body>
</html>
